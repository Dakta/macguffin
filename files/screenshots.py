from __future__ import print_function, unicode_literals, division, absolute_import
import subprocess
import logging
import os

import files
import image_hosts
import config


class Screenshots(object):

    def __init__(self, video_file_path):

        try:
            self.video_file = files.VideoFile(video_file_path)
        except files.VideoFileError as e:
            raise ScreenshotsError(e)

        self.bbcode = ''
        self.links = []
        self.files = []
        self.uploaded = False

    def verify(self):
        """
        Check to see if the output files exist.
        """
        for path in self.files:
            if not os.path.isfile(path):
                return False
        return True

    def delete(self):
        """
        Delete all local screenshot files generated by this object.
        """
        for path in self.files:
            if os.path.isfile(path):
                os.unlink(path)
        self.files = []

    def take(self):
        """
        Generate screenshots with ffmpeg
        """

        if self.files and self.verify():
            logging.error('Taking screenshots a second time is pointless...')
            return

        self.files = []

        # Get video's playback resolution, if it differs from the stored resolution
        try:
            playback_resolution = self.video_file.get_playback_resolution()
        except files.VideoFileError as e:
            raise ScreenshotsError(e)

        # Get video duration in ms
        duration = self.video_file.get_duration()

        # Do some magic to make seeking both fast and frame-accurate
        gop_duration = self.video_file.get_gop_duration()

        # Take twice as many shots as we'll need, so we can keep the best ones
        num_screens = config.NUM_SCREENSHOTS * 2

        # We'll be taking a shot every 'step' seconds
        step = duration / (num_screens + 1)

        # Don't want to overwrite the wrong files in /tmp, so prefix with a random string
        unique_string = files.utils.generate_id()

        msg = 'Taking {n} screenshots...'
        logging.info(msg.format(n=num_screens))

        for i in range(num_screens):
            # Screenshot will be taken at this time code (in seconds)
            time_code = int(step * (i + 1))

            # Overwrite files
            command = '"{ffmpeg}" -y'.format(ffmpeg=config.FFMPEG_PATH)

            # Fast seek to some point before the time code
            if time_code > gop_duration:
                command += ' -ss {seconds}'.format(seconds=(time_code - gop_duration))

            # Video file
            command += ' -i "{input_file}"'.format(input_file=self.video_file.path)

            # Accurate seek to the time code
            if time_code > gop_duration:
                command += ' -ss {seconds}'.format(seconds=gop_duration)
            else:
                command += ' -ss {seconds}'.format(seconds=time_code)

            # Set output path
            path = '/tmp/{unique_string}_{time_code}.png'.format(unique_string=unique_string, time_code=time_code)

            # Set the output resolution for videos that get stretched during playback
            if playback_resolution is not None:
                command += ' -s {resolution}'.format(resolution=playback_resolution)

            # Take one frame, and save it to the output path
            command += ' -vframes 1 {output_file}'.format(output_file=path)

            logging.debug(command)
            try:
                subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
            except subprocess.CalledProcessError as e:
                msg = 'Error while taking screenshots: {error_string}'
                raise ScreenshotsError(msg.format(error_string=e.output.decode(encoding='utf-8')))

            self.files.append(path)

        assert len(self.files) == num_screens
        assert self.verify()

        msg = 'Selecting the best {n} screenshots...'
        logging.info(msg.format(n=config.NUM_SCREENSHOTS))

        # Sort the screenshots by file size (a decent approximation of the amount of detail they contain)
        sized_screens = sorted([(os.path.getsize(path), path) for path in self.files])

        # Delete the smaller half of the set
        for (size, path) in sized_screens[:config.NUM_SCREENSHOTS]:
            os.unlink(path)

        # Keep the rest
        self.files = [path for (size, path) in sized_screens[config.NUM_SCREENSHOTS:]]

    def upload(self, image_host=image_hosts.ImageBam):
        """
        Upload local screenshot files to an image host.
        """

        # Check to make sure the files we expect to exist actually do exist
        if not self.verify():
            raise ScreenshotsError('Could not upload screenshots; the files do not exist!')

        # Check to make sure we actually have something to upload
        if not self.files:
            logging.warning('There are no screenshots to upload!')
            return

        # Upload
        assert issubclass(image_host, image_hosts.BaseImageHost)
        image_host = image_host()
        try:
            self.uploaded = image_host.upload(self.files)
        except image_hosts.ImageHostError as e:
            raise ScreenshotsError(e)

        # If the upload was successful, get links and bbcode, then delete the local files
        if self.uploaded is True:

            assert image_host.urls
            assert image_host.bbcode_links

            # Get image URLs
            for link in image_host.urls:
                logging.info(link)
                self.links.append(link)

            # Get BBCode
            self.bbcode += '[center][spoiler=Screenshots]'
            for bbcode_link in image_host.bbcode_links:
                self.bbcode += bbcode_link
            self.bbcode += '[/spoiler][/center]\n'

            # Delete local files
            if config.DELETE_SCREENS_AFTER_UPLOAD:
                self.delete()


class ScreenshotsError(Exception):
    pass